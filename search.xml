<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Beautify The Mac Bash Base on iTerm2 And oh-my-zsh</title>
    <url>/2022/04/02/%20Beautify-The-Mac-Bash/</url>
    <content><![CDATA[<p>在公司实习需要使用mac电脑来进行工作，其中bash是非常重要的工具，本文也是对bash进行了美化，提升使用的效率。<br>本文采用的方案是利用ITerm2 与 oh-my-zsh来进行美化,同时也要将其配置在vscode中。</p>
<p>在配置的过程中，发现如果路径层级过长，主机名的信息较长，会导致代码容易换行，影响观看。所以选了隐藏路径以及主机名，仅保留当前文件名，效果如图所示：</p>
<p><img src="/2022/04/02/%20Beautify-The-Mac-Bash/demo.jpg" alt="demo show1"></p>
<span id="more"></span>

<h1 id="1-Iterm2安装及其陪配置"><a href="#1-Iterm2安装及其陪配置" class="headerlink" title="1. Iterm2安装及其陪配置"></a>1. Iterm2安装及其陪配置</h1><p>手动安装: <a href="https://iterm2.com/">打开Iterm2 的官方网址</a>，下载相应的Iterm2 安装包，并安装。<br>Homebrew安装: 为了方便后期管理，采用homebrew进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># use brew to install iterm2</span></span><br><span class="line">brew install iTerm2</span><br></pre></td></tr></table></figure>

<p>设置iTerm2为默认的终端</p>
<center>
    <img src="/2022/04/02/%20Beautify-The-Mac-Bash/default-iterm2.jpg" width="80%">
</center>

<p>设置iTerm2的字体为 <em>Meslo LG L DZ for powerline</em>，之后vscode的terminal字体也设置为<em>Meslo LG L DZ for powerline</em>。</p>
<h1 id="2-oh-my-zsh"><a href="#2-oh-my-zsh" class="headerlink" title="2. oh-my-zsh"></a>2. oh-my-zsh</h1><p> 首先，在进入oh-my-zsh之前，要先了解zsh。</p>
<blockquote>
<p> <strong>zsh又称为z-shell</strong>，是一款可用作交互式登录的shell及脚本编写的命令解释器。Zsh对Bourne shell做出了大量改进，同时加入了Bash、ksh及tcsh的某些功能。自2019年起，macOS的默认Shell已从Bash改为Zsh。</p>
</blockquote>
<p> zsh 有如下几个特点：</p>
<ul>
<li>可帮助用户键入常用命令选项及参数的可编程命令行补全功能，自带对数百条命令的支持</li>
<li>可与任意Shell共享命令历史</li>
<li>多种兼容模式（例如，Zsh可在运行为&#x2F;bin&#x2F;sh的情况下伪装成Bourne shell）</li>
<li>自带where命令，其与which命令类似，但是显示指定于$PATH中所指定指令的全部位置，而不是仅显示所使用指令的位置。</li>
</ul>
<p>其中，用户社区网站”Oh My Zsh”收集Z shell的第三方插件及主题。</p>
<p>本文也是利用oh-my-zsh来美化oh-my-zsh，利用如下指令进行安装，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># curl 安装</span></span><br><span class="line"><span class="built_in">export</span> REMOTE=https://gitee.com/imirror/ohmyzsh.git</span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://cdn.jsdelivr.net/gh/ohmyzsh/ohmyzsh/tools/install.sh)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wget安装</span></span><br><span class="line"><span class="built_in">export</span> REMOTE=https://gitee.com/imirror/ohmyzsh.git</span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget -O- https://cdn.jsdelivr.net/gh/ohmyzsh/ohmyzsh/tools/install.sh)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fetch安装</span></span><br><span class="line"><span class="built_in">export</span> REMOTE=https://gitee.com/imirror/ohmyzsh.git</span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(fetch -o - https://cdn.jsdelivr.net/gh/ohmyzsh/ohmyzsh/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>安装界面如下：</p>
<center>
<img src="/2022/04/02/%20Beautify-The-Mac-Bash/oh-my-zsh安装.jpg" width="80%">
</center>

<h1 id="3-主题配置"><a href="#3-主题配置" class="headerlink" title="3. 主题配置"></a>3. 主题配置</h1><p>oh-my-zsh主题很多，其中 <em>agnoster</em> 是比较常用的主题，本文也是打算使用该主题（更多的主题可以查看<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">theme主题</a>。</p>
<h1 id="3-1-ZSH-THEME配置"><a href="#3-1-ZSH-THEME配置" class="headerlink" title="3.1 ZSH_THEME配置"></a>3.1 ZSH_THEME配置</h1><p>打开 ~&#x2F;.zshrc,修改ZSH-THEME这一配置.</p>
<blockquote>
<p><em>zshrc</em> file is where <em>you’d place customizations to the z shell</em>.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZSH_THEME =&quot;agnoster</span><br></pre></td></tr></table></figure>
<center>
<img src="/2022/04/02/%20Beautify-The-Mac-Bash/ZSH_THEME.jpg" width="80%">
</center>

<h1 id="3-2-字体安装与配置"><a href="#3-2-字体安装与配置" class="headerlink" title="3.2  字体安装与配置"></a>3.2  字体安装与配置</h1><p>注意agnoster需要安装额外的字体<a href="https://cdn.jsdelivr.net/gh/powerline/fonts/Meslo%20Slashed/Meslo%20LG%20S%20Regular%20for%20Powerline.ttf">Meslo for Powerline</a>,　下载安装相应的ttf文件。</p>
<p>配置完字体之后，打开iTerm -&gt; Preferences -&gt; Profiles -&gt; Text -&gt; Change Font，选择Meslo LG S Regular for Powerline。</p>
<center>
    <img src="/2022/04/02/%20Beautify-The-Mac-Bash/iterm-pref.jpg" , width="80%">
</center>


<center>
    <img src="/2022/04/02/%20Beautify-The-Mac-Bash/zsh-font.jpg" , width="80%">
</center>

<center>
    <img src="/2022/04/02/%20Beautify-The-Mac-Bash/zsh-demo.jpg" , width="80%">
</center>

<h1 id="4-优化zsh"><a href="#4-优化zsh" class="headerlink" title="4. 优化zsh"></a>4. 优化zsh</h1><p>在3.2 中，看到安装oh-my-zsh后的效果。但是存在一定的不足，比如命令行开头都有主机名，文件路径，能够看到当层级增多的时候，会显得非常的长，影响输入，需要一定的优化。笔者选择的方式，是隐去主机名和层级路径，仅保留用户名和当前文件路径，当需要查看路径的时候调用指令pwd即可。</p>
<h1 id="4-1-隐藏主机名"><a href="#4-1-隐藏主机名" class="headerlink" title="4.1 隐藏主机名"></a>4.1 隐藏主机名</h1><p>根据3.1可知，zsh的配置信息主要在~&#x2F;.zshrc这个文件，在该<strong>文件底部增加</strong>下添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># * 方法一：隐藏主机和用户名-是笔者选择的方案</span></span><br><span class="line"><span class="function"><span class="title">prompt_context</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：隐藏主机名</span></span><br><span class="line"><span class="function"><span class="title">prompt_context</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$USER</span>&quot;</span> != <span class="string">&quot;<span class="variable">$DEFAULT_USER</span>&quot;</span> || -n <span class="string">&quot;<span class="variable">$SSH_CLIENT</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    prompt_segment black default <span class="string">&quot;%(!.%&#123;%F&#123;yellow&#125;%&#125;.)<span class="variable">$USER</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三：隐藏用户名</span></span><br><span class="line"><span class="function"><span class="title">prompt_context</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$USER</span>&quot;</span> != <span class="string">&quot;<span class="variable">$DEFAULT_USER</span>&quot;</span> || -n <span class="string">&quot;<span class="variable">$SSH_CLIENT</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    prompt_segment black default <span class="string">&quot;%(!.%&#123;%F&#123;yellow&#125;%&#125;.)<span class="variable">$HOST</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#  更新 ~/.zshrc</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>

<h1 id="4-2-隐藏层级路径，保留当前路径"><a href="#4-2-隐藏层级路径，保留当前路径" class="headerlink" title="4.2 隐藏层级路径，保留当前路径"></a>4.2 隐藏层级路径，保留当前路径</h1><p>在路径 &#x2F;Users&#x2F;username&#x2F;.oh-my-zsh&#x2F;themes&#x2F;agnoster.zsh-theme 下，打开后找到prompt_dir() {}这个函数，然后将prompt_segment blue black ‘%~’ , 最后面的波浪线改为c即可：prompt_segment blue black ‘%c’,。</p>
<p>最后调用指令 source &#x2F;User&#x2F;username&#x2F;.zshrc, 完成刷新，实现了保留用户名以及当前层级用户。</p>
<center>
    <img src="/2022/04/02/%20Beautify-The-Mac-Bash/hide-host-name.jpg" , width="80%">
</center>

<h1 id="5-插件"><a href="#5-插件" class="headerlink" title="5. 插件"></a>5. 插件</h1><p>为了进一步提高zsh的效率，笔者添加了部分插件。但是，调用终端的好处在于其快速，便捷，过多的插件反而会使得终端显得臃肿，得不偿失，我们故仅添加必要的插件。<br>首先安装oh-my-zsh，打开~&#x2F;.zshrc文件找到plugins&#x3D;( git )，这里是我们已经启用了那些插件.如果想要启用某个插件，装好之后直接修改</p>
<blockquote>
<p>plugins &#x3D; (插件A 插件B 插件C)</p>
</blockquote>
<ol>
<li><p>zsh-autosuggestions<br>非常好用的一个插件，会记录你之前输入过的所有命令，并且自动匹配你可能想要输入命令，然后按→补全</p>
</li>
<li><p>zsh-syntax-highlighting<br>这个插件直接在输入过程中就会提示你，当前命令是否正确，错误红色，正确绿色</p>
</li>
</ol>
<h1 id="6-vscode-配置"><a href="#6-vscode-配置" class="headerlink" title="6. vscode 配置"></a>6. vscode 配置</h1><p>在vscode中有可能会出现乱码的情况，这是因为终端的字体没有设置好。在设置搜索中，打开setting.json文件，加入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;terminal.integrated.defaultProfile.osx&quot;</span>: <span class="string">&quot;zsh&quot;</span>,</span><br><span class="line"><span class="string">&quot;terminal.integrated.fontFamily&quot;</span>: <span class="string">&quot;Meslo LG L DZ for Powerline&quot;</span>,</span><br></pre></td></tr></table></figure>

<h1 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h1><p><a href="https://iterm2.com/">1. Iterm2官方文档以及下载链接</a></p>
<p><a href="https://segmentfault.com/a/1190000039834490">2. mac之 iTerm2 + Oh My Zsh 终端安装教程</a></p>
<p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">3. oh-my-zsh theme主题方案</a></p>
<p><a href="https://0clickjacking0.github.io/2020/10/04/oh-my-zsh%E9%9A%90%E8%97%8F%E7%94%A8%E6%88%B7%E5%90%8D%E6%88%96%E8%80%85%E4%B8%BB%E6%9C%BA%E5%90%8D/">4. oh-my-zsh 隐藏主机名</a></p>
<p><a href="https://www.jianshu.com/p/ee442cb4d6c2">5. Bash shell &#x2F; Zsh 里修改前缀 (隐藏用户@主机，添加Git分支名称)</a></p>
<p><a href="https://www.ioiox.com/archives/34.html">6.macOS使用oh-my-zsh美化Terminal,iTerm2,VSCode命令行终端配置教程</a></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>zsh</tag>
        <tag>iterm2</tag>
      </tags>
  </entry>
  <entry>
    <title>A Private Blog Built By Github + Hexo + NexT</title>
    <url>/2022/03/18/A-Private-Blog-Built-By-Github-Hexo-Next/</url>
    <content><![CDATA[<p>这个私人博客的搭建是基于Github Page创建最基础的个人静态网站，Hexo则是一个快速、简洁且高效的博客框架，利用Markdown进行文章的解析，NexT是其中的一种主题theme，其拓展性优秀，后期能基于该框架与主题进行个性化的修改。基于Github + Hexo + NexT模式的博客在管理方便，实现本地-远程简单部署的同时，也保证了博客网页的美观与整洁。</p>
<p>本文将从以下几个部分来记录该博客的搭建:</p>
<pre><code>- 项目构建及其部署
- 配置文件功能解析
- 基于该框架主题的DIY
- 难点与收获
</code></pre>
<span id="more"></span>


<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        度过了迷茫的半年，终于摸清楚了自己未来职业的方向，不再畏畏缩缩，要勇于去拼搏，去争取机会。在接下来的5年会是我未来非常重要的一段时光，实习、研究生、工作等等，每一步得需要万分的努力才能一步一个台阶的往上爬。所以我想创捷属于自己的blog，来记录自己未来几年的自己在技术、项目、职场等方面的一些心得与体会。之前也有类似的想法，但是经常就是做到一半中途而废。这次我是想认真的经营自己blog，不断的督促自己学习进步。同时blog也利于自己对过去经历进行记录与复盘，查漏补缺更进一步。</p>
<p>​        这个私人博客的搭建是基于Github Page创建最基础的个人静态网站，Hexo则是一个快速、简洁且高效的博客框架，利用Markdown进行文章的解析，NexT是其中的一种主题theme，其拓展性优秀，后期能基于该框架与主题进行个性化的修改。基于Github + Hexo + NexT模式的博客在管理方便，本地-远程简单部署的同时，也保证了博客网页的美观与整洁。</p>
<p>​        本文将从以下几个部分来记录该博客的搭建:</p>
<ul>
<li>项目构建及其部署</li>
<li>配置文件功能解析</li>
<li>基于该框架主题的DIY</li>
<li>难点与收获</li>
</ul>
<p>​        个人链接: </p>
<blockquote>
<ol>
<li><p><a href="https://github.com/wjmars98">Mars’ Github Home</a></p>
</li>
<li><p><a href="https://wjmars98.github.io/">Mars’ Blog Home Page</a></p>
</li>
</ol>
</blockquote>
<h1 id="项目构建及其部署"><a href="#项目构建及其部署" class="headerlink" title="项目构建及其部署"></a>项目构建及其部署</h1><h2 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h2><p>​        该博客主要是利用Github为其每个用户提供的Github Pages服务，允许用户搭建一个静态网站。所以首先需要Github上构建名为:{username}.github.io的仓库，其名字必须由“.github.io”结尾。同时为了后续的操作便利，<a href="https://docs.github.com/cn/authentication/connecting-to-github-with-ssh/about-ssh">需要配置本地与Github的ssh连接</a>。</p>
<p>​        同时还需安装Node.js，Hexo。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># node.js</span></span><br><span class="line"><span class="comment"># download from https://nodejs.org/zh-cn/download/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hexo 安装</span></span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>



<center>
    <img src="/2022/03/18/A-Private-Blog-Built-By-Github-Hexo-Next/build_repository.png" width="80%">
</center>



<center>
     <img src="/2022/03/18/A-Private-Blog-Built-By-Github-Hexo-Next/ssh-key.png" width="80%">
</center>



<h2 id="项目初始及本地搭建"><a href="#项目初始及本地搭建" class="headerlink" title="项目初始及本地搭建"></a>项目初始及本地搭建</h2><p>​        首先, 需要创建项目，利用指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo init &#123;name&#125;</span></span><br><span class="line"><span class="comment"># 我的项目名为wjmars98</span></span><br><span class="line">hexo init wjmars98</span><br></pre></td></tr></table></figure>

<p>在wjmars98文件夹下面出现Hexo的初始化文件，各个文件的具体细节下一章再展开。</p>
<center>
     <img src="/2022/03/18/A-Private-Blog-Built-By-Github-Hexo-Next/file_structure.png" width="80%">
</center>

<p>​        第二，需要将Hexo编译成HTML文件，调用指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译形成HTML文件</span></span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<p>输出结果里面包含了 js、css、font 等内容，处在了项目根目录下的 public 文件夹下面，随后利用Hexo提供的Server服务，将其在本地运行起来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动hexo服务器</span></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>随后可以在本地4000端口查看博客站点，如下所示,其中图例是已经选用next的情况。</p>
<center>
     <img src="/2022/03/18/A-Private-Blog-Built-By-Github-Hexo-Next/hexo_server.png" width="80%">
</center>



<center>
     <img src="/2022/03/18/A-Private-Blog-Built-By-Github-Hexo-Next/localhost.png" width="80%">
</center>



<h2 id="项目部在Github-Page上的部署"><a href="#项目部在Github-Page上的部署" class="headerlink" title="项目部在Github Page上的部署"></a>项目部在Github Page上的部署</h2><p>​        为了便利后面的操作，我们将部署的shell脚本写在 <em>deploy.sh</em> 的脚本文件上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deploy.sh 文件</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>利用 <em>sh deploy.sh</em> 指令就能完成部署操作。</p>
<p>​        在部署之前，我们还需要修改部署文件细节。打开根目录下的 _config.yml 文件，找到 Deployment 这个地方，把刚才新建的 Repository 的地址贴过来，然后指定分支为 master 分支，最终修改为如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  <span class="comment"># 替换成个人github上的git地址</span></span><br><span class="line">  repo: &#123;git repo ssh address&#125;</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>还需安装支持 Git 的部署插件，名字叫做 hexo-deployer-git，然后才能顺利部署到Github上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插件安装</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署命令</span></span><br><span class="line">sh deploy.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不按照会报错</span></span><br><span class="line"><span class="comment"># Deployer not found: git</span></span><br></pre></td></tr></table></figure>

<center>
     <img src="/2022/03/18/A-Private-Blog-Built-By-Github-Hexo-Next/deploy.png" width="80%">
</center>

<p>​        此时打开<a href="https://wjmars98.github.io/">https://wjmars98.github.io</a> 便可以打开网站。</p>
<h1 id="配置文件功能解析"><a href="#配置文件功能解析" class="headerlink" title="配置文件功能解析"></a>配置文件功能解析</h1><p>​        在第二章中，我们初步完成了hexo地搭建以及在Github Page上地部署，文件夹为wjmars98，本章将对该文件夹下地配置文件进行详细解析。    </p>
<p>​        首先是wjmars98文件夹的文件树:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml <span class="comment"># 网站的 配置 信息，您可以在此配置大部分的参数</span></span><br><span class="line">├── package.json <span class="comment"># 应用程序的信息。</span></span><br><span class="line">├── scaffolds <span class="comment"># 模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</span></span><br><span class="line">├── <span class="built_in">source</span> <span class="comment"># 资源文件夹是存放用户资源的地方。</span></span><br><span class="line">|   ├── _drafts	<span class="comment"># 草稿</span></span><br><span class="line">|   └── _posts <span class="comment"># 文章</span></span><br><span class="line">└── themes <span class="comment"># 主题 文件夹。Hexo 会根据主题来生成静态页面。</span></span><br></pre></td></tr></table></figure>

<p>​        我们可以在_config.yml中修改大部分配置。</p>
<h2 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h2><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>title</code></td>
<td align="left">网站标题</td>
</tr>
<tr>
<td align="left"><code>subtitle</code></td>
<td align="left">网站副标题</td>
</tr>
<tr>
<td align="left"><code>description</code></td>
<td align="left">网站描述</td>
</tr>
<tr>
<td align="left"><code>keywords</code></td>
<td align="left">网站的关键词。支持多个关键词。</td>
</tr>
<tr>
<td align="left"><code>author</code></td>
<td align="left">您的名字</td>
</tr>
<tr>
<td align="left"><code>language</code></td>
<td align="left">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td>
</tr>
<tr>
<td align="left"><code>timezone</code></td>
<td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td>
</tr>
</tbody></table>
<h2 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h2><table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数</td>
<td align="left">描述</td>
<td align="left">默认值</td>
</tr>
<tr>
<td align="left"><code>source_dir</code></td>
<td align="left">资源文件夹，这个文件夹用来存放内容。</td>
<td align="left"><code>source</code></td>
</tr>
<tr>
<td align="left"><code>public_dir</code></td>
<td align="left">公共文件夹，这个文件夹用于存放生成的站点文件。</td>
<td align="left"><code>public</code></td>
</tr>
<tr>
<td align="left"><code>tag_dir</code></td>
<td align="left">标签文件夹</td>
<td align="left"><code>tags</code></td>
</tr>
<tr>
<td align="left"><code>archive_dir</code></td>
<td align="left">归档文件夹</td>
<td align="left"><code>archives</code></td>
</tr>
<tr>
<td align="left"><code>category_dir</code></td>
<td align="left">分类文件夹</td>
<td align="left"><code>categories</code></td>
</tr>
<tr>
<td align="left"><code>code_dir</code></td>
<td align="left">Include code 文件夹，<code>source_dir</code> 下的子目录</td>
<td align="left"><code>downloads/code</code></td>
</tr>
<tr>
<td align="left"><code>i18n_dir</code></td>
<td align="left">国际化（i18n）文件夹</td>
<td align="left"><code>:lang</code></td>
</tr>
<tr>
<td align="left"><code>skip_render</code></td>
<td align="left">跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 <code>public</code> 目录中。您可使用 <a href="https://github.com/micromatch/micromatch#extended-globbing">glob 表达式</a>来匹配路径。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Writing"><a href="#Writing" class="headerlink" title="Writing"></a>Writing</h2><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>new_post_name</code></td>
<td align="left">新文章的文件名称</td>
<td align="left">:title.md</td>
</tr>
<tr>
<td align="left"><code>default_layout</code></td>
<td align="left">预设布局</td>
<td align="left">post</td>
</tr>
<tr>
<td align="left"><code>auto_spacing</code></td>
<td align="left">在中文和英文之间加入空格</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><code>titlecase</code></td>
<td align="left">把标题转换为 title case</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><code>external_link</code></td>
<td align="left">在新标签中打开链接</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><code>external_link.enable</code></td>
<td align="left">在新标签中打开链接</td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left"><code>external_link.field</code></td>
<td align="left">对整个网站（<code>site</code>）生效或仅对文章（<code>post</code>）生效</td>
<td align="left"><code>site</code></td>
</tr>
<tr>
<td align="left"><code>external_link.exclude</code></td>
<td align="left">需要排除的域名。主域名和子域名如 <code>www</code> 需分别配置</td>
<td align="left"><code>[]</code></td>
</tr>
<tr>
<td align="left"><code>filename_case</code></td>
<td align="left">把文件名称转换为 (1) 小写或 (2) 大写</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left"><code>render_drafts</code></td>
<td align="left">显示草稿</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><code>post_asset_folder</code></td>
<td align="left">启动 <a href="https://hexo.io/zh-cn/docs/asset-folders">Asset 文件夹</a></td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><code>relative_link</code></td>
<td align="left">把链接改为与根目录的相对位址</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><code>future</code></td>
<td align="left">显示未来的文章</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><code>highlight</code></td>
<td align="left">代码块的设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#Highlight-js">Highlight.js</a> 进行设置</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>prismjs</code></td>
<td align="left">代码块的设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#PrismJS">PrismJS</a> 进行设置</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>Hexo 使用 <a href="http://momentjs.com/">Moment.js</a> 来解析和显示时间。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>date_format</code></td>
<td align="left">日期格式</td>
<td align="left"><code>YYYY-MM-DD</code></td>
</tr>
<tr>
<td align="left"><code>time_format</code></td>
<td align="left">时间格式</td>
<td align="left"><code>HH:mm:ss</code></td>
</tr>
<tr>
<td align="left"><code>updated_option</code></td>
<td align="left">当 Front Matter 中没有指定 <a href="https://hexo.io/zh-cn/docs/variables#%E9%A1%B5%E9%9D%A2%E5%8F%98%E9%87%8F"><code>updated</code></a> 时 <code>updated</code> 的取值</td>
<td align="left"><code>mtime</code></td>
</tr>
</tbody></table>
<h2 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h2><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>theme</code></td>
<td align="left">当前主题名称。值为<code>false</code>时禁用主题</td>
</tr>
<tr>
<td align="left"><code>theme_config</code></td>
<td align="left">主题的配置文件。在这里放置的配置会覆盖主题目录下的 <code>_config.yml</code> 中的配置</td>
</tr>
<tr>
<td align="left"><code>deploy</code></td>
<td align="left">部署部分的设置</td>
</tr>
<tr>
<td align="left"><code>meta_generator</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#%E5%B1%9E%E6%80%A7">Meta generator</a> 标签。 值为 <code>false</code> 时 Hexo 不会在头部插入该标签</td>
</tr>
</tbody></table>
<h2 id="Front-Matter"><a href="#Front-Matter" class="headerlink" title="Front-Matter"></a>Front-Matter</h2><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2013</span><span class="string">/7/13</span> <span class="number">20</span><span class="string">:46:25</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>layout</code></td>
<td align="left">布局</td>
<td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td>
</tr>
<tr>
<td align="left"><code>title</code></td>
<td align="left">标题</td>
<td align="left">文章的文件名</td>
</tr>
<tr>
<td align="left"><code>date</code></td>
<td align="left">建立日期</td>
<td align="left">文件建立日期</td>
</tr>
<tr>
<td align="left"><code>updated</code></td>
<td align="left">更新日期</td>
<td align="left">文件更新日期</td>
</tr>
<tr>
<td align="left"><code>comments</code></td>
<td align="left">开启文章的评论功能</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><code>tags</code></td>
<td align="left">标签（不适用于分页）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>categories</code></td>
<td align="left">分类（不适用于分页）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>permalink</code></td>
<td align="left">覆盖文章网址</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>excerpt</code></td>
<td align="left">Page excerpt in plain text. Use <a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">this plugin</a> to format the text</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>disableNunjucks</code></td>
<td align="left">Disable rendering of Nunjucks tag <code>&#123;&#123; &#125;&#125;</code>&#x2F;<code>&#123;% %&#125;</code> and <a href="https://hexo.io/docs/tag-plugins">tag plugins</a> when enabled</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>lang</code></td>
<td align="left">Set the language to override <a href="https://hexo.io/docs/internationalization#Path">auto-detection</a></td>
<td align="left">Inherited from <code>_config.yml</code></td>
</tr>
</tbody></table>
<p>​        </p>
<p>更多细节可以查阅:<a href="https://hexo.io/zh-cn/docs/configuration">官方文档</a></p>
<h1 id="基于NexT框架主题的DIY"><a href="#基于NexT框架主题的DIY" class="headerlink" title="基于NexT框架主题的DIY"></a>基于NexT框架主题的DIY</h1><p>​        我们选择框架在themes文件夹下，文件树如图所示:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml <span class="comment"># 主题的配置文件。</span></span><br><span class="line">├── languages	<span class="comment"># 语言文件夹</span></span><br><span class="line">├── layout <span class="comment"># 布局文件夹</span></span><br><span class="line">├── scripts <span class="comment"># 脚本文件夹</span></span><br><span class="line">└── <span class="built_in">source</span> <span class="comment"># 资源文件夹，除了模板以外的 Asset，例如 CSS、JavaScript 文件等，都应该放在这个文件夹中</span></span><br></pre></td></tr></table></figure>

<p>​        目前 Hexo 里面应用最多的主题基本就是 Next 主题了，个人感觉这个主题还是挺好看的，另外它支持的插件和功能也极为丰富，配置了这个主题，我们的博客可以支持更多的扩展功能，比如阅览进度条、中英文空格排版、图片懒加载等等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>​        执行完毕之后 <a href="https://theme-next.js.org/">Next 主题</a>的源码就会出现在项目的 themes&#x2F;next 文件夹下。 然后我们需要修改下博客所用的主题名称，修改项目根目录下的 _config.yml 文件，找到 theme 字段，修改为 next 即可，修改如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>



<h1 id="难点与收获"><a href="#难点与收获" class="headerlink" title="难点与收获"></a>难点与收获</h1><h2 id="Tags-And-Categories"><a href="#Tags-And-Categories" class="headerlink" title="Tags And Categories"></a>Tags And Categories</h2><p>​        只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line"><span class="keyword">tags:</span></span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure>

<p>但是 Hexo <strong>不支持指定多个同级分类</strong>。下面的指定方法：</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">categories</span><span class="punctuation">:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Life</span></span><br></pre></td></tr></table></figure>

<p><em>会使分类<code>Life</code>成为<code>Diary</code>的子分类</em>，而不是并列分类.</p>
<p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p>
<figure class="highlight ldif"><table><tr><td class="code"><pre><span class="line"><span class="attribute">categories</span>:</span><br><span class="line"><span class="literal">-</span> [Diary, PlayStation]</span><br><span class="line"><span class="literal">-</span> [Diary, Games]</span><br><span class="line"><span class="literal">-</span> [Life]</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<ol>
<li><u><a href="https://hexo.io/zh-cn/">Hexo官方参考资料</a></u></li>
<li><a href="https://cuiqingcai.com/7625.html">崔庆才-利用 GitHub + Hexo + Next 从零搭建一个博客)</a></li>
<li><a href="https://docs.github.com/cn/authentication/connecting-to-github-with-ssh/about-ssh">Github的SSH连接</a></li>
<li><a href="https://www.npmjs.com/package/hexo-asset-image-for-hexo5">Hexo 图片部署</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Brew</title>
    <url>/2022/03/28/Homebrew/</url>
    <content><![CDATA[<p>在使用mac系统的时候，和win 的一个区别在于sofeware的安装，要将从int下载下来的包，拽入app store中，安装在指定的位置。后来发现mac中存在一个工具——homebrew，能有效的帮助用户下载和管理相应的应用软件。本文也是记录下一些常用的homebrew的用法，提高homebrew的使用。</p>
<blockquote>
<p>What Does Homebrew Do?</p>
<ul>
<li>Homebrew installs the stuff you need that Apple (or your Linux system) didn’t.</li>
<li>Homebrew installs packages to their own directory and then symlinks their files into &#x2F;usr&#x2F;local (on macOS Intel).</li>
<li>It’s all Git and Ruby underneath, so hack away with the knowledge that you can easily revert your modifications and merge upstream updates.</li>
</ul>
</blockquote>
<center>
  <img src="/2022/03/28/Homebrew/logo.png" width="80%">
</center>

<span id="more"></span>

<h1 id="What-Is-Homebrew"><a href="#What-Is-Homebrew" class="headerlink" title="What Is Homebrew?"></a>What Is Homebrew?</h1><p>Homebrew: 是一款自由及开放源代码的软件包管理系统，用以简化macOS系统上的软件安装过程，最初由马克斯·霍威尔（Max Howell）写成。因其可扩展性得到了一致好评，而在Ruby on Rails社区广为人知。</p>
<p>Homebrew使用GitHub，通过用户的贡献扩大对软件包的支持。2012年，Homebrew是GitHub上拥有最多新贡献者的项目。2013年，Homebrew同时成为GitHub上最多贡献者及最多已关闭问题的项目。</p>
<p>默认安装在&#x2F;usr&#x2F;local，由一个核心git版本库构成，以使用户能更新Homebrew。包管理器使用一种称为“公式”（formula）的DSL脚本来管理依赖、下载源代码及配置和编译软件，从源代码中构建软件。称为“瓶”（bottle）的二进制包是用默认选项预编译好的公式。</p>
<h1 id="安装、配置与使用流程"><a href="#安装、配置与使用流程" class="headerlink" title="安装、配置与使用流程"></a>安装、配置与使用流程</h1><h2 id="homebrew的安装"><a href="#homebrew的安装" class="headerlink" title="homebrew的安装"></a>homebrew的安装</h2><ol>
<li>调用安装指令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载安装脚本</span></span><br><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装路径</span></span><br><span class="line"><span class="comment"># curl 安装路径</span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/Homebrew</span><br></pre></td></tr></table></figure>
<center>
  <img src="/2022/03/28/Homebrew/homebrew_path.jpg" width="80%">
</center></li>
</ol>
<p>如果在国内，使用brew会有一定的限制，可以选择换源,确保homebrew的使用。</p>
<blockquote>
<p><em>笔者国内的公司可以合法访问外网，所以并未进行相应的换源。</em></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 替换为清华镜像源</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span></span><br><span class="line">git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换homebrew-core.git</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span></span><br><span class="line">git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新源</span></span><br><span class="line">brew update</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 替换为阿里云源</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span></span><br><span class="line">git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换homebrew-core.git</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span></span><br><span class="line">git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新源</span></span><br><span class="line">brew update</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 替换为腾讯云源</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>&quot;</span></span><br><span class="line">git remote set-url origin https://mirrors.cloud.tencent.com/homebrew/brew.git</span><br><span class="line"></span><br><span class="line">替换homebrew-core.git:</span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span></span><br><span class="line">git remote set-url origin https://mirrors.cloud.tencent.com/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新源</span></span><br><span class="line">brew update</span><br></pre></td></tr></table></figure>
<h1 id="cask"><a href="#cask" class="headerlink" title="cask"></a>cask</h1><p>brew 是从下载源码解压然后 .&#x2F;configure &amp;&amp; make install ，同时会包含相关依存库。并自动配置好各种环境变量，而且易于卸载。 </p>
<p>brew cask 是 已经编译好了的应用包 （.dmg&#x2F;.pkg），仅仅是下载解压，放在统一的目录中（&#x2F;opt&#x2F;homebrew-cask&#x2F;Caskroom），省掉了自己去下载、解压、拖拽（安装）等蛋疼步骤，同样，卸载相当容易与干净。这个对一般用户来说会比较方便，包含很多在 AppStore 里没有的常用软件。</p>
<p>也可以理解为，<strong>brew针对CLI程序，brew cask解决GUI程序的安装</strong>。</p>
<p>brew 另一个好处可以管理软件的升级。</p>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><ol>
<li>安装CLI软件以curl为例<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># homebrew 安装curl</span></span><br><span class="line">brew install curl</span><br></pre></td></tr></table></figure>
<img src="/2022/03/28/Homebrew/homebrew_install.jpg"></li>
</ol>
<p>可以看到，curl的安装路径在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/Cellar/curl/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>To clarify: The “Cellar” directory is a location that Homebrew made up for its own use. (The name fits with Homebrew’s “beer” theme: the “cellar” is where you store your “kegs” of “homebrew”.) No other software uses it. So if you don’t need Homebrew and the programs you installed using Homebrew, you can delete Cellar.</p>
</blockquote>
<ol start="2">
<li>安装GUI软件以有道词典为例:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># homebrew 安装有道词典</span></span><br><span class="line">brew install --cask youdaodict</span><br></pre></td></tr></table></figure>
<center>
  <img src="/2022/03/28/Homebrew/youdaodict.jpg" width="80%">
</center></li>
</ol>
<center>
  <img src="/2022/03/28/Homebrew/youdaologo.jpg" width="80%">
  </center>

<h1 id="brew-常用方法"><a href="#brew-常用方法" class="headerlink" title="brew 常用方法"></a>brew 常用方法</h1><ul>
<li>安装软件: brew install git</li>
<li>卸载软件: brew uninstall git</li>
<li>搜索软件: brew search git</li>
<li>显示已经安装软件列表: brew list</li>
<li>删除旧版本安装包缓存: brew cleanup git、brew cleanup</li>
<li>查看那些已安装的程序需要更新: brew outdated</li>
<li>更新软件，把所有的Formula目录更新: brew update</li>
<li>更新某具体软件: brew upgrade git</li>
<li>锁定某个软件禁止更新: brew pin git</li>
<li>解除禁更锁定: brew unpin git</li>
<li>查看brew存放安装包的缓存地址: brew –cache</li>
<li>显示安装的服务: brew services list</li>
<li>启动: brew services start mysql</li>
<li>停止: brew services stop mysql</li>
<li>重启: brew services restart mysql</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://www.zhihu.com/question/22624898">1. 知乎：brew和brew cask有什么区别？</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/325795191">2. 知乎：homebrew与brew的常用命令</a></p>
<p><a href="https://brew.sh/">3. homebrew 官方文档</a></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Internship Summary ASA</title>
    <url>/2022/04/07/Internship%20Summary%20ASA/</url>
    <content><![CDATA[<p>本文是为了记录与总结笔者在实习(前10天)中完成的第一个小项目——<strong>ASA(Apple Search Ads)投放数据拉取</strong>.<br>该项目大体由数据拉取、数据清洗、数据存储三个部分构成，笔者在这个项目中，目前实现了每天定时拉取应用数据，对其进行格式化处理，上传至Bigquery数据库中。</p>
<center>
    <img src="/2022/04/07/Internship%20Summary%20ASA/asa_logo.jpg" , width="80%">
</center>
<span id="more"></span>
]]></content>
      <categories>
        <category>Intership Summary</category>
      </categories>
      <tags>
        <tag>intership</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Fragments</title>
    <url>/2022/04/08/Linux-Fragments/</url>
    <content><![CDATA[<p>This article is used to record some knowledge fragments when using linux.</p>
<center>
        <img src="/2022/04/08/Linux-Fragments/linux-logo.png" width="80%">
</center>

<span id="more"></span>

<h1 id="bin-和-sbin-的区别"><a href="#bin-和-sbin-的区别" class="headerlink" title="bin 和 sbin 的区别"></a>bin 和 sbin 的区别</h1><p>&#x2F;bin目录（binary）是二进制执行文件目录，主要用于具体应用</p>
<p>&#x2F;sbin目录（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理</p>
<p>bin是binary的缩写，是可执行的二进制文件。&#x2F;bin里面一般是基本的，大家都要用的工具；sbin里面的s是system的意思，是供system administrator使用的工具。</p>
<blockquote>
<p>在hadoop中，&#x2F;bin 目录存放对Hadoop相关服务（HDFS, YARN）进行操作的脚本；&#x2F;sbin 目录存放启动或停止Hadoop相关服务的脚本</p>
</blockquote>
]]></content>
      <categories>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Pyenv</title>
    <url>/2022/04/02/Pyenv/</url>
    <content><![CDATA[<p>在python编程的过程中，经常需要在2.x 与  3.x 中进行切换，2和3两个版本间差异巨大，需要进行管理。</p>
<p>pyenv是一个forked自ruby社区的简单、低调、遵循UNIX哲学的Python环境管理工具, 它可以轻松切换全局解释器版本, 同时结合vitualenv插件可以方便的管理对应的包源.</p>
<p>pyenv和virtualenv。前者用于管理不同的Python版本，后者用 于管理不同的工作环境，能够极好得解决我们工作学习中遇到的python版本环境控制问题。</p>
<span id="more"></span>

<h1 id="Pyenv简介"><a href="#Pyenv简介" class="headerlink" title="Pyenv简介"></a>Pyenv简介</h1><p>如前言所言，pyenv允许用户在不同版本的python中切换。pyenv基于rbenv进行开发，由ruby语言进行编程，为python而准备的。</p>
<h2 id="Pyenv-用处"><a href="#Pyenv-用处" class="headerlink" title="Pyenv 用处"></a>Pyenv 用处</h2><ol>
<li>允许用户更改全局python的版本</li>
<li>为每个python版本都提供支持</li>
<li>允许使用环境变量重写python版本</li>
<li>有助于使用 tox 跨 Python 版本进行测试</li>
</ol>
<h2 id="Pyenv-不允许"><a href="#Pyenv-不允许" class="headerlink" title="Pyenv 不允许"></a>Pyenv 不允许</h2><ol>
<li>pyenv是由shell 脚本编写的，不存在python的引导问题。</li>
<li>需要将把pyenv安装目录载入到环境中。</li>
<li>pyenv无法管理虚拟环境，但是可以利用 virtualenv或者 pyenv-virtualenv实现。</li>
</ol>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>pyenv 就是使用了中间层的原理来实现的的，即 shims&#x2F;垫片。</p>
<h2 id="初始化-pyenv"><a href="#初始化-pyenv" class="headerlink" title="初始化 pyenv"></a>初始化 pyenv</h2><p>安装 pyenv 后，需要在当前 shell 的配置文件（bash 为 ~&#x2F;.bashrc，zsh 为 ~&#x2F;.zshrc 等等）中增加相应命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim ~/.bashrc</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/data/sammyshen/.pyenv/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv init -)</span>&quot;</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(pyenv virtualenv-init -)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这几个命令在每次登陆 shell 时，会更改 PATH 环境变量，将 pyenv 的路径加入到 PATH 环境变量前面。</p>
<h2 id="shims-x2F-垫片的简化基本原理"><a href="#shims-x2F-垫片的简化基本原理" class="headerlink" title="shims&#x2F;垫片的简化基本原理"></a>shims&#x2F;垫片的简化基本原理</h2><p>Linux 执行命令时，是依次遍历 PATH 环境变量的每个路径，查找所执行的命令。当在某个目录下找到第一个匹配时即停止遍历，所以 PATH 环境变量中，前面的路径比后面的路径具有更高的优先级。</p>
<p>pyenv 在 <del>&#x2F;.pyenv&#x2F;shims 目录下创建了各种 python 相关命令的垫片（</del>&#x2F;.bashrc 中加入的命令调用 pyenv-rehash 生成的，pyenv install 命令也会调用 pyenv-rehash 进行更新）</p>
<center>
        <img src="/2022/04/02/Pyenv/shim.jpg">
</center>

<p>从脚本内容可以看出，当我们执行某个命令 program “param1” “param2” ……时，实际执行的是 pyenv exec “program” “param1” “param2” ……。</p>
<p>例如执行 python -V，实际执行的是 pyenv exec python -V。</p>
<h2 id="确定版本号"><a href="#确定版本号" class="headerlink" title="确定版本号"></a>确定版本号</h2><p>在 pyenv-exec 命令中，首先会调用 pyenv-version-name 确定 python 版本或虚拟环境版本，具体查找规则为：</p>
<center>
        <img src="/2022/04/02/Pyenv/Pyenv 确定版本号.jpg" width="80%">
</center>

<h2 id="确定与版本号对应的可执行文件"><a href="#确定与版本号对应的可执行文件" class="headerlink" title="确定与版本号对应的可执行文件"></a>确定与版本号对应的可执行文件</h2><p>在 pyenv-exec 命令中，会再调用 pyenv-which 确定可执行文件 program 的路径。如果前面 pyenv-version-name 确定了 python 版本或虚拟环境版本，则使用 &lt;pyenv 安装路径&gt;&#x2F;versions&#x2F;&lt;版本号&gt;&#x2F;bin&#x2F;&lt;程序名&gt; 或 &lt;pyenv 安装路径&gt;&#x2F;versions&#x2F;&lt;版本号&gt;&#x2F;env&#x2F;&lt;虚拟环境名&gt;&#x2F;bin&#x2F;&lt;程序名&gt;，否则遍历所有版本号的安装路径，按顺序取第一个匹配到的可执行文件。</p>
<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>确定与版本号对应的可执行文件路径 path 之后，执行以下命令：<br>exec -a program “$path” “param1” “param2” ……</p>
<p>（注：即执行 “$path” “param1” “param2”，并使用 program 作为程序名，程序名即 shell 中的 $0，python 中的 sys.argv0）<br>例如执行 python -V，确定 pyenv 版本为 2.7.17，对应可执行文件为 ~&#x2F;.pyenv&#x2F;versions&#x2F;2.7.17&#x2F;bin&#x2F;python，则执行命令为：<br>exec -a python ~&#x2F;.pyenv&#x2F;versions&#x2F;2.7.17&#x2F;bin&#x2F;python -V<br>以上就是 pyenv 执行命令的基本原理了。</p>
<h1 id="pyenv常用指令"><a href="#pyenv常用指令" class="headerlink" title="pyenv常用指令"></a>pyenv常用指令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新的环境,位于 ~/.pyenv/versions/</span></span><br><span class="line">$ pyenv virtualenv 2.7.1 env271</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到新的环境</span></span><br><span class="line">$ pyenv activate env271</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退回到系统环境</span></span><br><span class="line">$ pyenv deactivate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除新创建的环境</span></span><br><span class="line">$ <span class="built_in">rm</span> -rf ~/.pyenv/versions/env271/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前 pyenv 可检测到的所有版本，处于激活状态的版本前以 * 标示。</span></span><br><span class="line">$ pyenv versions</span><br><span class="line">  system</span><br><span class="line">* 3.5.1 (<span class="built_in">set</span> by /root/.pyenv/version)</span><br><span class="line">  3.5.1/envs/flask_py351</span><br><span class="line">  3.5.1/envs/pelican</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前处于激活状态的版本，括号中内容表示这个版本是由哪条途径激活的（global、local、shell）</span></span><br><span class="line">$ pyenv version</span><br><span class="line">3.5.1 (<span class="built_in">set</span> by /root/.pyenv/version)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 python-build（一个插件） 安装一个 Python 版本，到 $PYENV_ROOT/versions 路径下。</span></span><br><span class="line">$ pyenv install -v 2.7.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">$ pyenv uninstall 2.7.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为所有已安装的可执行文件 （如：~/.pyenv/versions/*/bin/*） 创建 shims，</span></span><br><span class="line"><span class="comment"># 因此，每当你增删了 Python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令</span></span><br><span class="line">$ pyenv <span class="built_in">rehash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。</span></span><br><span class="line">$ pyenv global 3.4.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置面向程序的本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。</span></span><br><span class="line"><span class="comment"># 通过这种方式设置的 Python 版本优先级较 global 高。pyenv 会从当前目录开始向上逐级查找 .python-version 文件，直到根目录为止。</span></span><br><span class="line"><span class="comment">#若找不到，就用 global 版本。</span></span><br><span class="line">$ pyenv <span class="built_in">local</span> 2.7.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION 环境变量的方式。</span></span><br><span class="line"><span class="comment"># 这个版本的优先级比 local 和 global 都要高。--unset 参数可以用于取消当前 shell 设定的版本。</span></span><br><span class="line">$ pyenv shell pypy-2.2.1</span><br><span class="line">$ pyenv shell --<span class="built_in">unset</span></span><br></pre></td></tr></table></figure>

<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://github.com/pyenv/pyenv">1. pyenv-官方文档</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1593478">2. pyenv神器原理分析</a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL</title>
    <url>/2022/04/05/SSL/</url>
    <content><![CDATA[<p>在处理实习的业务需求的时候，涉及到ssl公钥私钥部分的相关知识。本文用以记录与ssl相关的基础知识及其应用。</p>
<center>
        <img src="/2022/04/05/SSL/SSL encrypted.jpg" width="60%">
</center>

<span id="more"></span>

<h1 id="What-is-SSL"><a href="#What-is-SSL" class="headerlink" title="What is SSL?"></a>What is SSL?</h1><p>安全套接字层 (SSL) 是一种加密安全协议。它最初由 Netscape 于 1995 年开发，旨在确保 Internet 通信中的隐私、身份验证和数据完整性。SSL 是如今使用的现代 TLS 加密的前身。</p>
<p>实施 SSL&#x2F;TLS 的网站的 URL 中带有“HTTPS”，而不是“HTTP”。</p>
<h2 id="TLS-握手"><a href="#TLS-握手" class="headerlink" title="TLS 握手"></a>TLS 握手</h2><blockquote>
<p>TLS 是一种旨在保护互联网通信安全的加密协议。TLS 握手是启动 TLS 加密通信会话的过程。在 TLS 握手过程中，通信双方交换消息以相互确认，彼此验证，确立它们将使用的加密算法，并生成一致的会话密钥。TLS 握手是 HTTPS 工作原理的基础部分。</p>
</blockquote>
<center>
        <img src="/2022/04/05/SSL/TLS.jpg" width="80%">
</center>

<p>通过 TCP 握手打开 TCP 连接后，将发生 TLS 握手。</p>
<h2 id="TLS握手会发生什么"><a href="#TLS握手会发生什么" class="headerlink" title="TLS握手会发生什么"></a>TLS握手会发生什么</h2><ul>
<li>指定将要使用的 TLS 版本（TLS 1.0、1.2、1.3 等）</li>
<li>决定将要使用哪些密码套件（见下文）</li>
<li>通过服务器的公钥和 SSL 证书颁发机构的数字签名来验证服务器的身份</li>
<li>生成会话密钥，以在握手完成后使用对称加密</li>
</ul>
<h2 id="TLS步骤"><a href="#TLS步骤" class="headerlink" title="TLS步骤"></a>TLS步骤</h2><p>TLS 握手的确切步骤将根据所使用的密钥交换算法的类型以及双方支持的密码套件而有所不同。RSA 密钥交换算法最为常用。</p>
<ol>
<li>“客户端问候（client hello）” 消息： 客户端通过向服务器发送“问候”消息来开始握手。该消息将包含<strong>客户端支持的 TLS 版本</strong>，<strong>支持的密码套件</strong>，以及称为一串称为“<strong>客户端随机数（client random）</strong>”的随机字。</li>
<li>“服务器问候（server hello）”消息： 作为对 client hello 消息的回复，服务器发送一条消息，内含<strong>服务器的 SSL 证书</strong>、服务器选择的<strong>密码套件</strong>，以及“<strong>服务器随机数</strong>（server random）”，即由服务器生成的另一串随机字节。</li>
<li>身份验证： 客户端使用颁发该证书的证书颁发机构验证服务器的 SSL 证书。此举确认服务器是其声称的身份，且客户端正在与该域的实际所有者进行交互。</li>
<li>预主密钥： 客户端再发送一串随机字节，即“<strong>预主密钥（premaster secret）</strong>”。预主密钥是<strong>使用公钥加密的，只能使用服务器的私钥解密</strong>。（客户端从服务器的 SSL 证书中获得公钥。）</li>
<li>私钥被使用：服务器对预主密钥进行解密</li>
<li>生成会话密钥：<strong>客户端和服务器均使用客户端随机数、服务器随机数和预主密钥生成会话密钥</strong>。双方应得到相同的结果。</li>
<li>客户端就绪：客户端发送一条“已完成”消息，该消息用会话密钥加密。</li>
<li>服务器就绪：服务器发送一条“已完成”消息，该消息用会话密钥加密。</li>
<li>实现安全对称加密：已完成握手，并使用会话密钥继续进行通信。</li>
</ol>
<h2 id="Diffie-Hellman-握手过程"><a href="#Diffie-Hellman-握手过程" class="headerlink" title="Diffie-Hellman 握手过程"></a>Diffie-Hellman 握手过程</h2><p>所有 TLS 握手均使用非对称加密（公钥和私钥），但并非全都会在生成会话密钥的过程中使用私钥。例如，短暂的 Diffie-Hellman 握手过程如下：</p>
<ol>
<li>客户端问候：客户端发送客户端问候消息，内含协议版本、客户端随机数和密码套件列表。</li>
<li>服务器问候：服务器以其 SSL 证书、其选定的密码套件和服务器随机数回复。与上述 RSA 握手相比，服务器在此消息中还包括以下内容（步骤 3）：</li>
<li>服务器的数字签名：<strong>服务器使用其私钥对客户端随机数、服务器随机数及其 DH 参数</strong> 进行加密。加密后的数据用作服务器的数字签名，从而确定<strong>服务器具有与 SSL 证书中的公钥相匹配的私钥</strong>。</li>
<li>确认数字签名：客户端使用公钥解密服务器的数字签名，验证服务器控制私钥并且是其声称的身份。客户端 DH 参数：客户端将其 DH 参数发送到服务器。</li>
<li>客户端和服务器计算预主密钥：客户端和服务器使用交换的 DH 参数分别计算匹配的预主密钥，而不像 RSA 握手那样由客户端生成预主密钥并将其发送到服务器。</li>
<li>创建会话密钥：与 RSA 握手中一样，客户端和服务器现在从预主密钥、客户端随机数和服务器随机数计算会话密钥。</li>
<li>客户端就绪：与 RSA 握手相同。</li>
<li>服务器就绪</li>
<li>实现安全对称加密</li>
</ol>
<h2 id="密码套件"><a href="#密码套件" class="headerlink" title="密码套件"></a>密码套件</h2><p>密码套件是一组用于建立安全通信连接的加密算法。（加密算法是对数据执行的一组数学运算，以使数据显得随机。）广泛使用的密码套件有多种，而且 TLS 握手的一个重要组成部分就是对这个握手使用哪一密码套件达成一致意见。</p>
<h2 id="使用会话密钥的对称加密"><a href="#使用会话密钥的对称加密" class="headerlink" title="使用会话密钥的对称加密"></a>使用会话密钥的对称加密</h2><p>与非对称加密不同，在对称加密中，会话中的两方使用相同的密钥。TLS 握手后，双方使用相同的会话密钥进行加密。一旦使用了会话密钥，就不再使用公钥和私钥。会话密钥是临时密钥，会话终止后便不再使用。下一会话需要创建一组新的随机会话密钥。</p>
<center>
        <img src="/2022/04/05/SSL/asymmetric.jpg" , width="80%">
</center>


<h1 id="验证源站服务器身份"><a href="#验证源站服务器身份" class="headerlink" title="验证源站服务器身份"></a>验证源站服务器身份</h1><p>来自服务器的 TLS 通信包括消息身份验证码或 MAC，它是用于确认通信源自实际网站的数字签名。这将对服务器进行身份验证，从而防止在途攻击和域欺骗。它还确保数据在传输过程中没有被篡改。</p>
<h1 id="什么是-SSL-证书？"><a href="#什么是-SSL-证书？" class="headerlink" title="什么是 SSL 证书？"></a>什么是 SSL 证书？</h1><p>SSL 证书是网站的源服务器上安装的文件。它只是一个数据文件，包含公钥和网站所有者身份以及其他信息。如果没有 SSL 证书，就无法使用 TLS 来加密网站的流量。</p>
<p>从技术上讲，任何网站所有者都可以创建自己的 SSL 证书，这些证书称为自签名证书。但是，浏览器不认为自签名证书像证书颁发机构颁发的 SSL 证书一样值得信赖。</p>
<h1 id="网站如何获得-SSL-证书？"><a href="#网站如何获得-SSL-证书？" class="headerlink" title="网站如何获得 SSL 证书？"></a>网站如何获得 SSL 证书？</h1><p>网站所有者需要从证书颁发机构获取 SSL 证书，然后将其安装到自己的 Web 服务器上（通常 Web 主机可以处理此过程）。证书颁发机构是一个外部方，可以确认网站所有者是他们所称的身份。他们保留所颁发证书的副本。</p>
<h1 id="HTTP-和-HTTPS-有什么区别？"><a href="#HTTP-和-HTTPS-有什么区别？" class="headerlink" title="HTTP 和 HTTPS 有什么区别？"></a>HTTP 和 HTTPS 有什么区别？</h1><p>“HTTPS”中的 S 代表“安全”。HTTPS 只是具有 SSL&#x2F;TLS 的 HTTP。拥有 HTTPS 地址的网站具有由证书颁发机构颁发的合法 SSL 证书，并且使用 SSL&#x2F;TLS 协议对往返于该网站的流量进行身份验证和加密。</p>
<p>为了鼓励整个互联网转向更安全的 HTTPS，许多 Web 浏览器已开始将 HTTP 网站标记为“不安全”。因此，HTTPS 不仅对于确保用户和用户数据的安全至关重要，而且对于建立与用户的信任也至关重要。测试网站的 SSL&#x2F;HTTPS 问题。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.cloudflare.com/zh-cn/learning/ssl/what-is-ssl/">1. Cloudflare 什么是ssl</a></p>
<p><a href="https://www.cloudflare.com/zh-cn/learning/ssl/what-happens-in-a-tls-handshake/">2. TLS握手</a></p>
]]></content>
      <categories>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title>Ripple--The News Real Time Heat Analysis Platform</title>
    <url>/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/</url>
    <content><![CDATA[<p>Ripple 该平台实现对当前新闻网舆论热点事件的实时可视化分析，主要在<a href="https://www.bilibili.com/video/BV1mK411T7WY?p=1">B站:新闻网大数据实时分析可视化系统</a>这一项目基础进行进一步改造，使用框架组件包括：Hadoop、Zookeeper、Flume、Kafka、Hive、HBase、Cloudera HUE、Spark、Echart等。</p>
<p>本文主要Ripple项目的业务分析、技术造型、集群规划、安装部署、整合集成与开发和可视化设计等部分组成。项目目标为充分理解搭建过程中涉及的大数据组件，提升个人相关开发能力。</p>
<span id="more"></span>
<h1 id="项目需求分析、架构设计、数据流程设计"><a href="#项目需求分析、架构设计、数据流程设计" class="headerlink" title="项目需求分析、架构设计、数据流程设计"></a>项目需求分析、架构设计、数据流程设计</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol>
<li>捕获用户浏览的日志信息(TB)</li>
<li>实时分析前20名流量最高的新闻话题</li>
<li>实时统计当前线上已曝光的新闻话题</li>
<li>统计哪些时段用户浏览量最高</li>
<li>报表</li>
</ol>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><center>
<img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/project_structure.png" width="80%">
</center>

<h2 id="数据流程"><a href="#数据流程" class="headerlink" title="数据流程"></a>数据流程</h2><center>
<img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/data_flow.png" width="80%">
</center>

<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="集群资源规划"><a href="#集群资源规划" class="headerlink" title="集群资源规划"></a>集群资源规划</h2><p>该项目出于学习目的，比较腾讯云、阿里云、华为云等云服务，选择租用腾讯云的高性能云服务器,由于我们选择同一子网下的三台机器，所以我们只需使用节点的内网ip即可，并且保证了数据传输速度。  </p>
<center>
<img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/cloud_machine.png" width="80%">
</center>

<p>三台服务器相关资源的部署规划如图所示:</p>
<center>
  <img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/cluster_resources.png" width="80%">
</center>

<br>

<p>为了方便三台云服务器间的数据传输与登录，需要设计三台云服务器间的ssh免密登录，其原理为将每台主机authorized_keys文件里面包含的主机（ssh密钥），该主机都能无密码登录，所以只要每台主机的authorized_keys文件里面都放入其他主机（需要无密码登录的主机）的ssh密钥即可,参考<a href="https://www.cnblogs.com/shireenlee4testing/p/10366061.html">Hadoop集群配置免密SSH登录方法</a>。</p>
<p>完成ssh免密登录之后，由于ip地址相对难以记忆，通过修改&#x2F;etc&#x2F;hosts中的映射关系，这样能够方便再服务期间传输文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用如下指令,在hosts末尾中添加ip映射</span></span><br><span class="line">vi /etc/hosts</span><br></pre></td></tr></table></figure>
<center>
  <img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/ssh.png">
</center>
<br>


<h2 id="Hadoop-搭建"><a href="#Hadoop-搭建" class="headerlink" title="Hadoop 搭建"></a>Hadoop 搭建</h2><p>首先，根据教程，再&#x2F;opt文件夹下文件树为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">|-- opt <span class="comment"># 主要文件夹</span></span><br><span class="line">|   |-- data <span class="comment"># 存放数据</span></span><br><span class="line">|   |-- modules <span class="comment"># haddop</span></span><br><span class="line">|   |-- softwares <span class="comment"># 相关软件下载包</span></span><br><span class="line">|   |-- tool <span class="comment"># 工具插件</span></span><br><span class="line">|</span><br></pre></td></tr></table></figure>
<p>在<a href="https://archive.apache.org/dist">A.hadoop资源下载</a>中，-&gt; hadoop -&gt; core -&gt;   hadoop-2.6.5.tar.gz，下载相关资源，并下载在software，最终解压至&#x2F;opt&#x2F;modules&#x2F;，重命名为hadoop。</p>
<p>其中hadoop文件夹中的各文件及其功能如图所示:</p>
<center>
    <img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/Hadoop_安装目录.png" , width="80%">
</center>

<ul>
<li>&#x2F;bin 目录存放对Hadoop相关服务（HDFS, YARN）进行操作的脚本；</li>
<li>&#x2F;etc 目录存放Hadoop的配置文件</li>
<li>&#x2F;lib 目录存放Hadoop的本地库（对数据进行压缩解压缩功能）</li>
<li>&#x2F;sbin 目录存放启动或停止Hadoop相关服务的脚本</li>
<li>&#x2F;share 目录存放Hadoop的依赖jar包、文档、和官方案例</li>
</ul>
<p>下载相关jdk也安装在&#x2F;opt&#x2F;modules中，配置&#x2F;etc&#x2F;profile环境变量。对于hadoop，有几个关键文件需要配置:</p>
<h3 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h3><p>路径: &#x2F;opt&#x2F;modules&#x2F;hadoop&#x2F;etc&#x2F;hadoop</p>
<p>功能:  配置集群全局参数属性，用于定义系统级别的参数，如HDFS URL 、Hadoop的临时目录等</p>
<center>
  <img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/core-site.png" width="80%">
</center>

<h3 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h3><p>路径: &#x2F;opt&#x2F;modules&#x2F;hadoop&#x2F;etc&#x2F;hadoop&#x2F;hdfs-site.xml</p>
<p>功能: 配置HDFS组件的属性，如名称节点和数据节点的存放位置、文件副本的个数、文件的读取权限等</p>
<center>
  <img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/hdfs-site.png" width="80%">
</center>

<h3 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h3><p>路径: &#x2F;opt&#x2F;modules&#x2F;hadoop&#x2F;etc&#x2F;hadoop&#x2F;mapred-site.xml</p>
<p>功能：配置map-reduce组件的属性，包括JobHistory Server 和应用程序参数两部分，如reduce任务的默认个数、任务所能够使用内存的默认上下限等</p>
<center>
    <img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/mapred-site.png" width="80%">
</center>


<h3 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h3><p>路径: &#x2F;opt&#x2F;modules&#x2F;hadoop&#x2F;etc&#x2F;hadoop&#x2F;yarn-site.xml</p>
<p>功能: 集群资源管理系统参数，配置ResourceManager ，nodeManager的通信端口，web监控端口等</p>
<center>
    <img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/yarn-site.png" width="80%">
</center>

<h3 id="hadoop-env-xml"><a href="#hadoop-env-xml" class="headerlink" title="hadoop-env.xml"></a>hadoop-env.xml</h3><p>路径: &#x2F;opt&#x2F;modules&#x2F;hadoop&#x2F;etc&#x2F;hadoop&#x2F;haddop-env.sh</p>
<p>功能: hadoop运行环境,用来定义hadoop运行环境相关的配置信息</p>
<center>
    <img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/hadoop-env.png" width="80%">
</center>

<h2 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h2><p>在2.2节中对hadoop文件夹下的bin与sbin进行了说明</p>
<blockquote>
<ul>
<li>&#x2F;bin 目录存放对Hadoop相关服务（HDFS, YARN）进行操作的脚本；</li>
<li>&#x2F;sbin 目录存放启动或停止Hadoop相关服务的脚本</li>
</ul>
</blockquote>
<p>在启动集群的时候，主要调用&#x2F;sbin中的函数。</p>
<p>首先,在<strong>第一次启动</strong>集群的时候，我们需要对Namenode进行格式化。</p>
<h3 id="NameNode的格式化"><a href="#NameNode的格式化" class="headerlink" title="NameNode的格式化"></a>NameNode的格式化</h3><p><strong>为什么需要格式化</strong></p>
<p>Hadoop NameNode是HDFS文件系统的集中位置，它保存文件系统中所有文件的目录树，并跟踪整个集群中文件数据的保存位置。简而言之，它将元数据与datanode保持相关。当我们格式化namenode时，它会<strong>格式化与数据节点相关的元数据</strong>。通过这样做，所有关于datanode的信息都将丢失，它们可以用于新数据。</p>
<p><strong>如何格式化</strong><br>格式化NameNode前，先关闭掉NameNode节点和DataNode节点，然后一定要删除hadoop目录下的data文件夹和log日志文件夹。最后再进行格式化。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/hadoop namenode -format</span><br></pre></td></tr></table></figure>
<h3 id="hdfs-yarn启动"><a href="#hdfs-yarn启动" class="headerlink" title="hdfs, yarn启动"></a>hdfs, yarn启动</h3><h4 id="hdfs启动流程"><a href="#hdfs启动流程" class="headerlink" title="hdfs启动流程"></a>hdfs启动流程</h4><p>在完成NameNode的格式化之后，可以开始启动 hdfs(NameNode, DataNode, SecondaryNameNode) 与 yarn（ResourceManager，NodeManager）。<br>首先，启动hdfs。在2.3中了解，sbin文件夹是用来存储集群启动、关闭等时候调用的文件，其内部主要文件机器功能如下：</p>
<center>
    <img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/sbin（存放启停hadoop服务的脚本文件）.png" width="80%">
</center>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先启动hdfs</span></span><br><span class="line">sbin/start-dfs.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动yarn</span></span><br><span class="line">sbin/start-yarn.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在ripple1的启动hdfs，yarn情况如下，ripple1，ripple2，ripple3正常启动</p>
</blockquote>
<center>
<img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/启动hdfs1.jpg" width="80%">
</center>

<center>
    <img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/启动yarn.jpg" width="80%">
</center>


<h4 id="hdfs启动出现问题"><a href="#hdfs启动出现问题" class="headerlink" title="hdfs启动出现问题"></a>hdfs启动出现问题</h4><p>Q1: sbin&#x2F;start-dfs.sh 后ripple2，ripple3机器datanode没有启动</p>
<p>A1: datanode与namenode 的clusterid不一致导致。</p>
<p>查看ripple2的日志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认在hadoop的路径下</span></span><br><span class="line">tail  -25 log/hadoop-root-datanode*.log</span><br></pre></td></tr></table></figure>

<center>
    <img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/Q-datanode启动失败.png" width="80%">
</center>


<p>可以看到错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2022-04-09 17:29:29,989 WARN org.apache.hadoop.hdfs.server.common.Storage: java.io.IOException: Incompatible clusterIDs in /tmp/hadoop-root/dfs/data: namenode clusterID = CID-55814a25-a013-48af-ad24-f4689b57728b; datanode clusterID = CID-34619a23-71d3-4112-9ab8-1d39fdbca5ad</span><br><span class="line">2022-04-09 17:29:29,989 FATAL org.apache.hadoop.hdfs.server.datanode.DataNode: Initialization failed for Block pool &lt;registering&gt; (Datanode Uuid unassigned) service to ripple1/172.17.0.13:9000. Exiting.</span><br><span class="line">java.io.IOException: All specified directories are failed to load.</span><br><span class="line">	at org.apache.hadoop.hdfs.server.datanode.DataStorage.recoverTransitionRead(DataStorage.java:478)</span><br><span class="line">	at org.apache.hadoop.hdfs.server.datanode.DataNode.initStorage(DataNode.java:1342)</span><br><span class="line">	at org.apache.hadoop.hdfs.server.datanode.DataNode.initBlockPool(DataNode.java:1308)</span><br><span class="line">	at org.apache.hadoop.hdfs.server.datanode.BPOfferService.verifyAndSetNamespaceInfo(BPOfferService.java:314)</span><br><span class="line">	at org.apache.hadoop.hdfs.server.datanode.BPServiceActor.connectToNNAndHandshake(BPServiceActor.java:226)</span><br><span class="line">	at org.apache.hadoop.hdfs.server.datanode.BPServiceActor.run(BPServiceActor.java:867)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:823)</span><br><span class="line">2022-04-09 17:29:29,990 WARN org.apache.hadoop.hdfs.server.datanode.DataNode: Ending block pool service for: Block pool &lt;registering&gt; (Datanode Uuid unassigned) service to ripple1/172.17.0.13:9000</span><br><span class="line">2022-04-09 17:29:30,091 INFO org.apache.hadoop.hdfs.server.datanode.DataNode: Removed Block pool &lt;registering&gt; (Datanode Uuid unassigned)</span><br></pre></td></tr></table></figure>
<p><strong>原因</strong><br>这是我们在format namnode的时候会重置，导致namenode 的clusterID与datanode的clusterID不一致。</p>
<blockquote>
<p>You will get this error when the cluster ID of name node and cluster ID of data node are different. We can see the cluster ID of name node in &lt;dfs.namenode.name.dir&gt;&#x2F;current&#x2F;VERSION file and cluster ID of data node in &lt;dfs.datanode.data.dir&gt;&#x2F;current&#x2F;VERSION file.</p>
</blockquote>
<p><strong>解决方案</strong>：</p>
<p>预防措施：在format namenode之前，我们需要删除所有datanode上的 &lt;dfs.datanode.data.dir&gt; 路径下的所有目录。</p>
<p>解决方案：</p>
<ul>
<li>方案一：如果hdfs中有数据且不想删除，复制namenode的version文件下的clusterID到各个datanode中的VERSION文件即可。</li>
<li>方案二：删除所有namnode与datanode的&lt;dfs.datanode.data.dir&gt; 下的文件，然后再重新format  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/hdfs namenode -format</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h4><p>利用yarn集群运行mapreduce程序，来测试hdfs与yarn是否正常启动。<br>主要代码为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">核心代码：利用yarn运行mapreduce程序</span></span><br><span class="line">bin/yarn jar share/hadoop/mapreduce/hadoop-examples-2.6.5 wordcount 数据源目录 数据输出目录</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">事例代码</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hdfs 构建文件夹 -<span class="built_in">mkdir</span> -p 路径</span></span><br><span class="line"> bin/hdfs dfs -mkdir -p /user/ripple/data/input/</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">本地文件存入hdfs之中</span></span><br><span class="line"> bin/hdfs dfs -put /opt/data/wc.input /user/ripple/data/input/</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">yarn调用mapreduce 进行wordcount计算</span></span><br><span class="line"> bin/yarn jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.6.5.jar wordcount /user/ripple/data/input/wc.input /user/ripple/data/output/wordcount</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash"> 查看运行结果</span></span><br><span class="line"> bin/hdfs dfs -text /user/ripple/data/output/wordcount/part*</span><br></pre></td></tr></table></figure>

<center>
    <img src="/2022/03/20/Ripple-The-News-Real-Time-Heat-Analysis-Platform/yarn启动mapreduce.png" width="80%">
</center>

<p>至此，hdfs与yarn的集群启动完毕。</p>
<h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><p>zookeeper 的部分可以查看<a href="https://wjmars98.github.io/2022/04/10/Zookeeper-Basic/">zookeeper基础</a>.</p>
<p><strong>未完待续 | To be continued</strong></p>
<h1 id="附录A：Problem"><a href="#附录A：Problem" class="headerlink" title="附录A：Problem"></a>附录A：Problem</h1><h1 id="附录B：参考网站"><a href="#附录B：参考网站" class="headerlink" title="附录B：参考网站"></a>附录B：参考网站</h1><ol>
<li><a href="https://www.bilibili.com/video/BV1mK411T7WY?p=1">B站:新闻网大数据实时分析可视化系统</a></li>
<li><a href="https://hadoop.apache.org/docs/r2.6.5/">Hadoop官方文档</a></li>
<li><a href="https://archive.apache.org/dist">A.hadoop资源下载</a></li>
<li><a href="http://archive.cloudera.com/cdh5">B.hadoop资源下载</a></li>
<li><a href="https://intellipaat.com/community/161/what-exactly-is-hadoop-namenode-formatting">What exactly is hadoop namenode formatting?</a></li>
<li><a href="https://sparkbyexamples.com/hadoop/incompatible-clusterids/">datanode无法启动</a></li>
</ol>
]]></content>
      <categories>
        <category>Private Projects</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Zookepper</tag>
        <tag>Flume</tag>
        <tag>Kafka</tag>
        <tag>Hive</tag>
        <tag>Hbase</tag>
        <tag>Spark</tag>
        <tag>Hue</tag>
      </tags>
  </entry>
  <entry>
    <title>Sql-Fragments</title>
    <url>/2022/04/11/Sql-Fragments/</url>
    <content><![CDATA[<p>This article is used for recording some study fragments in mysql.</p>
<center>
        <img src="/2022/04/11/Sql-Fragments/sf-logo.png" width="60%">
</center>

<span id="more"></span>

<h1 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce()"></a>coalesce()</h1><p>The COALESCE() function returns the first non-null value in a list.<br>返回列表中第一个非空元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># The <span class="built_in">COALESCE</span>() <span class="keyword">function</span> <span class="keyword">returns</span> the <span class="keyword">first</span> non<span class="operator">-</span><span class="keyword">null</span> <span class="keyword">value</span> <span class="keyword">in</span> a list.</span><br><span class="line"><span class="built_in">COALESCE</span>(val1, val2, ...., val_n)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="unnest"><a href="#unnest" class="headerlink" title="unnest"></a>unnest</h1><p>The UNNEST function takes an ARRAY and returns a table with a row for each element in the ARRAY.</p>
<p>unnest函数输入一个array数组，返回array数组中每一个元素作为行的表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># Syntax: <span class="built_in">UNNEST</span>(<span class="keyword">ARRAY</span>) [<span class="keyword">WITH</span> <span class="keyword">OFFSET</span>]</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="built_in">UNNEST</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="keyword">NULL</span>]) <span class="keyword">AS</span> unnest_column</span><br><span class="line"></span><br><span class="line"># <span class="keyword">Result</span></span><br><span class="line"># <span class="number">1</span></span><br><span class="line"># <span class="number">2</span></span><br><span class="line"># <span class="number">2</span></span><br><span class="line"># <span class="number">5</span></span><br><span class="line"># <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 其中还有一个<span class="keyword">offset</span>选项，为每一行提供了一个附加列，其中包含数组中每个元素的位置（从零开始）</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="built_in">UNNEST</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="keyword">NULL</span>]) <span class="keyword">AS</span> unnest_column <span class="keyword">WITH</span> <span class="keyword">OFFSET</span> <span class="keyword">AS</span> `<span class="keyword">offset</span>`</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Yarn</title>
    <url>/2022/04/08/Yarn/</url>
    <content><![CDATA[<p>YARN is an open source Apache project that stands for “Yet Another Resource Negotiator”. It is a Hadoop cluster manager that is responsible for allocating resources (such as cpu, memory, disk and network), for scheduling &amp; monitoring jobs across the Hadoop cluster.</p>
<p>YARN是Apache的一个开源项目，它的意思是“另一个资源协商者”。它是一个Hadoop集群管理器，负责分配资源(如cpu、内存、磁盘和网络)，用于跨Hadoop集群调度和监控作业。</p>
<center>
        <img src="/2022/04/08/Yarn/yarn_logo.png" , width="80%">
</center>
<span id="more"></span>

<h1 id="What-is-yarn"><a href="#What-is-yarn" class="headerlink" title="What is yarn"></a>What is yarn</h1><p>YARN是Apache的一个开源项目，它的意思是“另一个资源协商者”。它是一个Hadoop集群管理器，负责分配资源(如cpu、内存、磁盘和网络)，用于跨Hadoop集群调度和监控作业。</p>
<p>早期版本的Hadoop只支持在Hadoop集群上运行MapReduce任务;然而，YARN的出现也使得在Hadoop集群上运行其他大数据解决方案框架成为可能，比如Spark、Flink、Samza等。</p>
<p>YARN支持不同类型的工作负载，如流处理、批处理、图形处理和迭代处理。</p>
<h1 id="Yarn’s-Architecture"><a href="#Yarn’s-Architecture" class="headerlink" title="Yarn’s Architecture"></a>Yarn’s Architecture</h1><p>Apache YARN由两个主要组件组成:资源管理器和节点管理器。资源管理器每个集群一个，而节点管理器守护进程运行在所有工作节点上。</p>
<center>
        <img src="/2022/04/08/Yarn/yarn_architecture.jpg" , width="80%,">
</center>

<ol>
<li><p>资源管理器(Resource Manager)是一个守护进程，负责在集群中分配资源。它有两个主要组件，即<strong>调度程序和应用程序管理器</strong>。调度器负责根据内存和cpu需求跨集群调度应用程序。每个集群只有一个资源管理器。</p>
</li>
<li><p>应用程序管理器(APP Manager)接受作业并创建特定的应用程序主程序，并在出现故障时重新启动它们。<strong>Application Master负责处理Application的整个生命周期</strong>，从资源协商、跟踪和监控作业状态开始。</p>
</li>
<li><p>节点管理器(Node Manager)是运行在所有工作节点上的守护进程，在<strong>机器级别管理资源</strong>。节点管理器定义节点上可用的资源，并跟踪其使用情况。它还跟踪节点的运行状况，如果<strong>发现不正常，则将其通信给资源管理器</strong>。Node Manager与资源管理器通信，发送关于报告使用情况的定期报告，并与应用程序主机协调生成用于任务执行的JVM。</p>
</li>
</ol>
<h1 id="Yarn-Scheduler"><a href="#Yarn-Scheduler" class="headerlink" title="Yarn Scheduler"></a>Yarn Scheduler</h1><p>YARN 支持三种调度策略，即 FIFO、Capacity 和 Fair Scheduling，它们决定了传入作业的调度或优先级。</p>
<h2 id="FIFO-Scheduler"><a href="#FIFO-Scheduler" class="headerlink" title="FIFO Scheduler"></a>FIFO Scheduler</h2><p>在 FIFO 调度器策略中，应用程序以“先进先出”的方式提供服务，但如果集群在多个用户之间共享，此策略可能会导致作业匮乏。所以，这个策略在共享集群中并不是最优的。默认情况下，YARN 始终设置为 FIFO 策略。</p>
<h2 id="Capacity-Scheduler"><a href="#Capacity-Scheduler" class="headerlink" title="Capacity Scheduler:"></a>Capacity Scheduler:</h2><p>在容量调度程序中，不同的组织共享他们的 Hadoop 集群以最大限度地利用集群。尽管组织正在共享他们的集群，但容量调度程序可确保每个组织都获得所需的容量。</p>
<p>容量调度器(Capacity Scheduler)提供容量保证、弹性、基于资源的调度、优先级调度、多租户等等。我们必须在 conf&#x2F;yarn-site.xml 文件中设置以下属性以在 YARN 中启用容量调度程序。</p>
<h2 id="Fair-Scheduler"><a href="#Fair-Scheduler" class="headerlink" title="Fair Scheduler:"></a>Fair Scheduler:</h2><p>公平调度策略(Fair Scheduler)确保所有正在运行的作业获得大致相等的资源份额（内存或 CPU）。</p>
<p>作业被划分为队列，资源在这些队列之间平均共享。它始终保证队列的最小份额，如果队列为空，则将多余的资源分配给在其他队列中运行的作业。我们还可以定义一组应用于提交的应用程序的规则，以便应用程序进入适当的队列以进行进一步处理.</p>
<h1 id="High-Availability"><a href="#High-Availability" class="headerlink" title="High Availability"></a>High Availability</h1><p>在 Hadoop 2.4 之后，资源管理器以 Active&#x2F;StandBy 模式工作，以提供容错和高可用性。</p>
<p>Standby Resource Manager始终跟踪活动资源管理器中发生的所有更改，并可以在出现故障时替换其位置。资源管理器与zookeeper密切合作，记录其状态，并决定在出现故障时哪个资源管理器应该处于活动状态。</p>
<center>
        <img src="/2022/04/08/Yarn/active_standby.png" , width="80%">
</center>

<p>故障转移从active mode 到 standby mode 可以手动进行，也可以自动进行。</p>
<h2 id="手动转换与failover"><a href="#手动转换与failover" class="headerlink" title="手动转换与failover"></a>手动转换与failover</h2><p>当自动 <em>failover</em> 没有开启时，管理员需要手动将RM的状态转为Active。为了完成failover，首先需要将Active-RM 转换为Standby，然后将Standby-RM 转换为Active。这些均可以通过 <em>yarn rmadmin</em> 命令完成。</p>
<h2 id="自动failover"><a href="#自动failover" class="headerlink" title="自动failover"></a>自动failover</h2><p>RMs可以配置一个内置的，基于 Zookeeper 的ActiveStandbyElector，用于决定哪个RM应该是Active的。当Active RM 出现故障下线，或者无法响应了，另一个RM会被自动推选为Active，并接管之后的工作。需要注意的是，这里没有必要像 HDFS HA 那样运行一个额外的ZKFC守护进程，因为ActiveStandbyElector 内置于RM，担任failure detector以及leader elector的角色，可以替代ZKFC守护进程</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="aegissofttech.com/articles/what-is-yarn-in-big-data.html">1. What is YARN? How Does it Work and Support Big Data Framework?</a></p>
<p><a href="https://www.cnblogs.com/zackstang/p/10812523.html">2. YARN High Availablity</a></p>
<p><a href="https://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-site/YARN.html">3. Apache Hadoop YARN</a></p>
]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>yarn</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper Basic</title>
    <url>/2022/04/10/Zookeeper-Basic/</url>
    <content><![CDATA[<p>ZooKeeper是一个分布式、开源的分布式应用协调服务。它公开了一组简单的原语，分布式应用程序可以在此基础上构建，以实现同步、配置维护、组和命名等更高级别的服务。它的设计是易于编程的，并使用了一个数据模型，其样式类似于熟悉的文件系统的目录树结构。它在Java中运行，并且有Java和C的绑定。</p>
<p>众所周知，协调服务很难做好。它们特别容易出现竞争条件和死锁等错误。ZooKeeper背后的动机是为了减轻分布式应用从头开始实现协调服务的责任。</p>
<center>
        <img src="/2022/04/10/Zookeeper-Basic/Apache_ZooKeeper_logo.svg.png" width="80%">
</center>

<span id="more"></span>

<h1 id="What-is-zookeeper"><a href="#What-is-zookeeper" class="headerlink" title="What is zookeeper"></a>What is zookeeper</h1><p>ZooKeeper是一个分布式、开源的分布式<strong>应用协调服务</strong>。它公开了<strong>一组简单的原语</strong>，分布式应用程序可以在此基础上构建，以实现同步、配置维护、组和命名等更高级别的服务。它的设计是易于编程的，并使用了一个数据模型，其样式类似于熟悉的文件系统的目录树结构。它在Java中运行，并且有Java和C的绑定。</p>
<p>众所周知，协调服务很难做好。它们特别容易出现竞争条件和死锁等错误。ZooKeeper背后的动机是为了<strong>减轻分布式应用从头开始实现协调服务的责任</strong>。</p>
<h1 id="What-is-zookeeper’s-goals"><a href="#What-is-zookeeper’s-goals" class="headerlink" title="What is zookeeper’s goals?"></a>What is zookeeper’s goals?</h1><h2 id="zookeeper-结构简单"><a href="#zookeeper-结构简单" class="headerlink" title="zookeeper 结构简单"></a>zookeeper 结构简单</h2><p>ZooKeeper允许分布式进程通过一个<strong>共享的层次命名空间相互协调</strong>，这个命名空间的组织方式<strong>类似于标准的文件系统</strong>。命名空间由数据寄存器组成——用ZooKeeper的话说叫做znode——它们类似于文件和目录。与典型的存储文件系统不同，<strong>ZooKeeper的数据保存在内存中</strong>，这意味着ZooKeeper可以实现<strong>高吞吐量和低时延</strong>。</p>
<h2 id="zookeeper-是被复制的"><a href="#zookeeper-是被复制的" class="headerlink" title="zookeeper 是被复制的"></a>zookeeper 是被复制的</h2><center>
                <img src="/2022/04/10/Zookeeper-Basic/zookeeper_structure.jpg" width="80%">
</center>

<p>组成zookeeper的服务器都认识彼此，它们在内存中维护状态图像，以及持久存储中的事务日志和快照。只要大多数服务器可用，ZooKeeper 服务就可用。</p>
<p>**”2n+1原则”**：集群中运行的机器需要超过一半</p>
<ul>
<li>“2n+1”的原因是zookeeper应用需要可靠性&#x2F;可用性，与性能无关</li>
<li>ZooKeeper集合(服务集群)是由一个或多个服务器组成的，这些服务器对每个更改进行“投票”。大多数原始服务器在接受任何更改之前都需要“批准”。</li>
<li>集成中有 3 台服务器（n&#x3D;1），如果其中一台出现故障，服务仍然正常（2 台占多数）。但是，如果第二台服务器发生故障，则服务将关闭。</li>
</ul>
<h2 id="zookeeper是有序的"><a href="#zookeeper是有序的" class="headerlink" title="zookeeper是有序的"></a>zookeeper是有序的</h2><p>ZooKeeper 使用反映所有 ZooKeeper 事务顺序的数字标记每个更新。后续操作可以使用顺序来实现更高级别的抽象，例如同步原语。</p>
<h2 id="zookeeper很迅速"><a href="#zookeeper很迅速" class="headerlink" title="zookeeper很迅速"></a>zookeeper很迅速</h2><p>它在“以读取为主”的工作负载中尤其快。 ZooKeeper 应用程序在数千台机器上运行，它在读取比写入更常见的情况下表现最佳，比率约为 10:1。</p>
<h1 id="数据模型与命名空间"><a href="#数据模型与命名空间" class="headerlink" title="数据模型与命名空间"></a>数据模型与命名空间</h1><p>ZooKeeper 提供的命名空间很像标准文件系统。名称是由斜杠 (&#x2F;) 分隔的一系列路径元素。 ZooKeeper 命名空间中的每个节点都由路径标识。</p>
<center>
                <img src="/2022/04/10/Zookeeper-Basic/zookeeper_hn.jpg" width="80%">
</center>

<h2 id="节点与临时节点"><a href="#节点与临时节点" class="headerlink" title="节点与临时节点"></a>节点与临时节点</h2><p>与标准的文件系统不同，ZooKeeper名称空间中的每个节点都可以有与其关联的数据以及子节点。这就像拥有一个允许文件同时也是目录的文件系统。(ZooKeeper是用来<strong>存储协调数据</strong>的:<strong>状态信息、配置信息、位置信息</strong>等，所以每个节点存储的数据通常很小，在字节到千字节之间。)我们使用术语znode来说明我们谈论的是ZooKeeper数据节点。</p>
<p>znode维护一个统计结构，其中包括数据更改的版本号、ACL更改和时间戳，以允许缓存验证和协调更新。znode的数据每次更改，版本号就会增加。例如，每当客户端检索数据时，它也会接收到数据的版本。</p>
<p>存储在名称空间中的每个znode上的数据是原子式读写的。读获取与znode关联的所有数据字节，写则替换所有数据。每个节点都有一个访问控制列表(Access Control List, ACL)来限制谁可以做什么。</p>
<p>ZooKeeper也有临时节点的概念。只要创建znode的会话处于活动状态，这些znode就会存在。当会话结束时，删除znode。</p>
<h1 id="zookeeper特点"><a href="#zookeeper特点" class="headerlink" title="zookeeper特点"></a>zookeeper特点</h1><ul>
<li>顺序一致性</li>
<li>原子性</li>
<li>单一系统映像：无论客户端连接到哪个服务器，客户端都将看到相同的服务视图。即，即使客户端故障转移到具有相同会话的不同服务器，客户端也永远不会看到系统的旧视图。</li>
<li>可靠性</li>
<li>实效性</li>
</ul>
<h1 id="调用接口api"><a href="#调用接口api" class="headerlink" title="调用接口api"></a>调用接口api</h1><ul>
<li>create : creates a node at a location in the tree</li>
<li>delete : deletes a node</li>
<li>exists : tests if a node exists at a location</li>
<li>get data : reads the data from a node</li>
<li>set data : writes data to a node</li>
<li>get children : retrieves a list of children of a node</li>
<li>sync : waits for data to be propagated</li>
</ul>
<h1 id="zookeeper组成"><a href="#zookeeper组成" class="headerlink" title="zookeeper组成"></a>zookeeper组成</h1><p>除了请求处理器(request processor)之外，组成 ZooKeeper 服务的每个服务器都复制自己的每个组件的副本。</p>
<center>
<img src="/2022/04/10/Zookeeper-Basic/zk_component.jpg" width="80%">
</center>

<p>复制数据库是包含整个数据树的内存数据库。更新被记录到磁盘以便恢复，写入在应用到内存数据库之前被序列化到磁盘。</p>
<p>每个 ZooKeeper 服务器都服务于客户端。客户端仅连接到一台服务器以提交请求。<strong>从每个服务器数据库的本地副本为读取请求提供服务</strong>。请求会改变服务状态，其中写请求，由协议协议处理。</p>
<p>作为协议协议的一部分，来自客户端的所有写入请求都被转发到单个服务器，称为领导者（leader）。余下服务器称为跟随者（follower），并接收来自领导者的消息提议并同意消息传递。</p>
<h1 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h1><p>zookeeper在读超过写的时候，性能较高，因为写涉及到同步所有服务器的状态。</p>
<center>
                <img src="/2022/04/10/Zookeeper-Basic/zk_performance.jpg" width="80%">
</center>

<h1 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h1><blockquote>
<p>为了显示系统在注入故障时的行为，我们运行了一个由 7 台机器组成的 ZooKeeper 服务。我们运行与之前相同的饱和度基准测试，但这次我们将写入百分比保持在恒定的 30%，这是我们预期工作负载的保守比率。</p>
</blockquote>
<center>
                <img src="/2022/04/10/Zookeeper-Basic/zk_reliability.jpg" width="80%">
</center>

<p>图像中存在几个重要的观察特点：</p>
<ol>
<li><p>如果追随者失败并迅速恢复，那么即使失败，ZooKeeper 也能够维持高吞吐量。</p>
</li>
<li><p>领导者选举算法允许系统以足够快的速度恢复，以防止吞吐量大幅下降。ZooKeeper 用不到 200 毫秒的时间来选举一个新的领导者。</p>
</li>
<li><p>随着追随者的恢复，ZooKeeper 能够在他们开始处理请求后再次提高吞吐量。</p>
</li>
</ol>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://zookeeper.apache.org/doc/r3.4.14/zookeeperOver.html">1. zookeeper 概述</a></p>
<p><a href="https://stackoverflow.com/questions/4228227/what-does-2n-1-quorum-mean">2. zookeeper 2n+1 原理</a></p>
]]></content>
      <categories>
        <category>Big Data</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
</search>
